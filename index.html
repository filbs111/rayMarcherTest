<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>raymarcher test</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}
</style>

<!-- vertex shader with tex coords -->
<!-- start simple by just use 1 vec for ray direction. assume camera fixed at zero. likely should include matrix transformation for camera, pass through both ray start and direction as separate varying-->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	varying vec3 mynum;
	uniform mat4 uMVMatrix;
	uniform vec3 fovScale;
	uniform vec3 rayStartIn;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition,1.0);
		//mynum = 0.5*aVertexPosition.xy + 0.5;
	//	mynum = (aVertexPosition+vec3(0.0,0.0,1.0))*fovScale;	// z=1 for 90deg fov
	
		vec4 transformedCoord = uMVMatrix * vec4((aVertexPosition+vec3(0.0,0.0,1.0))*fovScale,1.0);	//TODO better to just use 3x3 so3 matrix?
		mynum = transformedCoord.xyz;
	
		vec4 cameraDirFourVec = uMVMatrix * vec4(0.0,0.0,1.0,0.0);
		vCameraDirection = cameraDirFourVec.xyz;
	
		rayStart = rayStartIn;	//later for near plane or ortho camera, this will vary across camera view.
	}
</script>

<script id="shader-fullscreen-equirect-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	varying vec3 mynum;
	uniform mat4 uMVMatrix;
	uniform vec3 fovScale;
	uniform vec3 rayStartIn;
	varying vec3 rayStart;
//	varying vec3 vCameraDirection;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition,1.0);
	
	
//		vec4 transformedCoord = uMVMatrix * vec4((aVertexPosition+vec3(0.0,0.0,1.0))*fovScale,1.0);	//TODO better to just use 3x3 so3 matrix?
		mynum = aVertexPosition.xyz * vec3(3.14,3.14/2.0,1.0);	//simple, no camera rotation. z coord not required
	
//		vec4 cameraDirFourVec = uMVMatrix * vec4(0.0,0.0,1.0,0.0);
	//	vCameraDirection = cameraDirFourVec.xyz;
	
		rayStart = rayStartIn;	//later for near plane or ortho camera, this will vary across camera view.
	}
</script>


<!-- fragment shader -->
<!-- super simple, just flat colour, then shade colour across image to check passing through vertex position stuff ok-->
<script id="shader-flatcolor-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		gl_FragColor = vec4(mynum.xy*0.5+0.5,0.0,1.0);
	}
</script>

<!-- fragment shader -->
<!-- single sphere raymarch-->
<script id="shader-raymarch1-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<10;ii++){
			//get distance estimate from rayPos
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(1.0-0.001*rayPos.w),1.0);
	}
</script>

<!-- fragment shader -->
<!-- square array spheres-->
<script id="shader-raymarch2-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<32;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy+2.0,4.0)-2.0;
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.00002*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres-->
<script id="shader-raymarch3-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch4-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			if (toSphere<0.02){numSteps=float(ii);break;}	//arbitary small number. 
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		gl_FragColor = vec4(vec3(max(0.0,1.0-numSteps/64.0)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch5-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			
			//rayPos = rayDir*rayPos.w;	//should have no effect
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.w){numSteps=float(ii)+(toSphere/(0.005*rayPos.w));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array tori-->
<script id="shader-raymarch6-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//float mynuminvsq = 1.0/dot(mynum,mynum);	//assuming that passing thru mynum with z=1 //is 1/x^2 a special shader function?
		//vec4 rayDir = vec4( mynum*vec3(2.0*mynuminvsq) - vCameraDirection , 1.0);
		//vec4 rayDir = vec4( normalize(mynum*vec3(2.0*mynuminvsq) - vCameraDirection*uCamCurve) , 1.0);	//continuous rectilinear to stereographic. (camcurve 0-1)
		
		//TODO is this equivalent to projection from variable position in sphere onto plane?
		//borrow code from webgl-wideanglecamera "getPointingDirectionFromScreenCoordinate" to get constant angular resolution in centre of view
		float var1 = uCamCurve*-0.125;
		//var var2 = parseFloat(10.0/guiParams.zoom);
		float var2 = 4.0;	//zoom
		
		//basically works, but how to make independent of camera rotation?
		//float zpos = 2.0 + var1*(var2*var2*dot(mynum.xy,mynum.xy));
		//vec4 rayDir = vec4( normalize( vec3(var2*mynum.xy,zpos ) ), 1.0);		
		
		//separation into plll, perp parts. can be simplified? at least, might precalc some stuff and pass into shader.
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		float toSphere;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toSphere = length(vec2(rad,toTorus.z)) -0.25;
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.w){numSteps=float(ii)+(toSphere/(0.005*rayPos.w));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
			
			rayPos+=toSphere*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		toTorus = rayPos.xyz - theTorus;
		rad = length(toTorus.xy)-1.5;
		float distanceDifference = (length(vec2(rad,toTorus.z)) -0.25) - toSphere;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges-->
<script id="shader-raymarch7-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			
			/*
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toObject = length(vec2(rad,toTorus.z)) -0.25;
			*/
			toObjectVec = rayPos.xyz - theTorus;
			vec3 absVec = abs(toObjectVec);
			
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			
			cubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
			
			//chop smaller holes out (will do this iteratively)
			toObjectVec*=3.0;
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/3.0);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.w){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.w));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		
		//toTorus = rayPos.xyz - theTorus;
		//rad = length(toTorus.xy)-1.5;
		toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		maxxy = max(absVec.x,absVec.y);
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		
		float newcubsdf;
		newcubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
		
		//chop smaller holes out (will do this iteratively)
		toObjectVec*=3.0;
		toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
		absVec = abs(toObjectVec);
		maxxy = max(absVec.x,absVec.y);	//square hole
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		newcubsdf = max(newcubsdf , (0.25-minhole)/3.0);
		
		float distanceDifference = newcubsdf - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges , use function instead of copy/paste-->
<script id="shader-raymarch8-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
	
	float sdfFunc(inout vec4 rayPos){
		rayPos.xy =mod(rayPos.xy,4.0);
		//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
		rayPos.z =mod(rayPos.z,8.0);
		
		vec3 toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		//float cubsdf = max(absVec.z,maxxy)-0.75;
		float cubsdf = length(max(absVec-vec3(0.75),0.0));	//more accurate. how does speed compare? todo use like this for holes? 
		//float cubsdf = length(max(absVec-vec3(0.75),0.0))-0.15;	//round edge! 
		
		//if (min(absVec.z,min(absVec.x,absVec.y))<0.1){cubsdf += 0.01;}	//abuse of "sdf" -> dark energy effect!!
		
		if (cubsdf>0.005){return cubsdf;}	//early exit if sufficiently outside cube.	what is ideal value?
		
		float maxxy = max(absVec.x,absVec.y);	//square hole
		float maxxz = max(absVec.x,absVec.z);	//square hole
		float maxyz = max(absVec.y,absVec.z);	//square hole
		float minhole = min(min(maxxy,maxxz),maxyz);
		
		cubsdf = max( cubsdf , 0.25-minhole);
		
		//chop smaller holes out TODO incorporate 1st hole cuts into this (above)
		
		//figure out how many iterations.
		int numIters = int(4.0/(1.0+0.03*rayPos.w));	//TODO should use z, and should be from camera
									//numbers guessed really should depend on screen resolution, fov
		
		float divideFactor=1.0;
		for (int ii=0;ii<4;ii++){	//high nums lead to horrible aliasing! TODO depth dependent on distance from cam?
			if (ii==numIters){break;}
			divideFactor*=3.0;
			toObjectVec*=3.0;
			
			//bodge for interesting
			//toObjectVec+=vec3(2.2,5.1,1.1);
			
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/divideFactor);
		}
		
		return cubsdf;
	}
	
	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.		
		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			cubsdf = sdfFunc(rayPos);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.w){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.w));break;}	//TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
					//TODO should use something else for stereographic projection camera (relates to size of pixel) 
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>

<script id="shader-raymarch8-equirect-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;

	vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
	
	float sdfFunc(inout vec4 rayPos){
		rayPos.xy =mod(rayPos.xy,4.0);
		//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
		rayPos.z =mod(rayPos.z,8.0);
		
		vec3 toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		//float cubsdf = max(absVec.z,maxxy)-0.75;
		float cubsdf = length(max(absVec-vec3(0.75),0.0));	//more accurate. how does speed compare? todo use like this for holes? 
		//float cubsdf = length(max(absVec-vec3(0.75),0.0))-0.15;	//round edge! 
		
		//if (min(absVec.z,min(absVec.x,absVec.y))<0.1){cubsdf += 0.01;}	//abuse of "sdf" -> dark energy effect!!
		
		if (cubsdf>0.005){return cubsdf;}	//early exit if sufficiently outside cube.	what is ideal value?
		
		float maxxy = max(absVec.x,absVec.y);	//square hole
		float maxxz = max(absVec.x,absVec.z);	//square hole
		float maxyz = max(absVec.y,absVec.z);	//square hole
		float minhole = min(min(maxxy,maxxz),maxyz);
		
		cubsdf = max( cubsdf , 0.25-minhole);
		
		//chop smaller holes out TODO incorporate 1st hole cuts into this (above)
		
		//figure out how many iterations.
		int numIters = int(4.0/(1.0+0.03*rayPos.w));	//TODO should use z, and should be from camera
									//numbers guessed really should depend on screen resolution, fov
		
		float divideFactor=1.0;
		for (int ii=0;ii<4;ii++){	//high nums lead to horrible aliasing! TODO depth dependent on distance from cam?
			if (ii==numIters){break;}
			divideFactor*=3.0;
			toObjectVec*=3.0;
			
			//bodge for interesting
			//toObjectVec+=vec3(2.2,5.1,1.1);
			
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/divideFactor);
		}
		
		return cubsdf;
	}
	
	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.		
		
		//equirectangular - want mynum to be scaled some specific amount
		//currently assuming that mynum is basically screen co-ords relative to centre of screen. suspect untrue.
		float elev = mynum.y;	//elevation
		float turn = mynum.x;
		vec4 rayDir = vec4( cos(turn)*cos(elev) , sin(elev), sin(turn)*cos(elev), 1.0);
		
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			cubsdf = sdfFunc(rayPos);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.w){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.w));break;}	//TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
					//TODO should use something else for stereographic projection camera (relates to size of pixel) 
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>

<!-- fragment shader -->
<!-- mandelbox copy paste from forum-->
<script id="shader-raymarch9-fs" type="x-shader/x-fragment">
	//basically copied from Rrola's code here http://www.fractalforums.com/3d-fractal-generation/a-mandelbox-distance-estimate-formula/15/
	//picked that because alter in thread, guess better optimised than earlier.

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.001
	
	#define ITERS 24
	#define SCALE 2.0
	#define MR2 0.16
	
	#define C1 1.0
	//C1 = abs(SCALE-1.0);
	
	#define CUBELIMIT 6.0 
	
	//For scale < -1 the mandelbox sides have length 4 and for 1 < scale <= 4?n+1 they have length 4(scale+1)/(scale-1)
	// what is n ? assuming condition correct (at least, n>=1) 
	
	// scale 1 , length 4(2/0)	-> inf!
	// scale 1.5, length 4(2.5/0.5) -> 20			half length =10
	// scale 1.75, length 4(2.75/0.75) -> 14.666	half length 7.333
	// scale 2 , length 4(3/1)  -> 12				half length =6
	// scale 2.5, length 4(3.5/1.5) -> 9.333		half length = 4.666
	// scale 3 , length 4(4/2) -> 8					half length =4
	// scale 4, length 4(5/3) -> 6.6666				half length = 3.333
	
	precision mediump float;
	uniform float uCamCurve;
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	vec4 scalevec;
	float C2;	//guess faster to hard code than calculate in main;

	float mbSdfFunc(in vec4 position){
		//should calculate halflength outside (eg by define or uniform)
		vec3 distFromSides = max(abs(position.xyz) - CUBELIMIT , 0.0);

		float distFromCube = length(distFromSides);
		//if (distFromCube>0.4){return distFromCube;}	//added some buffer outside - iterations outside this fast, buffer allows marching through cube limit to inside
													//TODO find best number
		float borderSize = 0.5;
		if (distFromCube>borderSize){return distFromCube;}
		distFromCube=max(distFromCube,0.0);	//to use as a blend factor to make continuous SDF
		
	  // distance estimate
	  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
	  for (int i=0; i<ITERS; i++) {	//hard coded iters? can set by define?
		p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3
		float r2 = dot(p.xyz, p.xyz);  // dp3
		p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
		p.xyzw = p*scalevec + p0;  // mad4
	  }
		
	  //return (length(p.xyz) - C1) / p.w - C2;
	  
	  //make sdf func continuous to reduce banding in num steps ?
	  float unmodifiedSdf = (length(p.xyz) - C1) / p.w - C2;
	  return mix(unmodifiedSdf,distFromCube,distFromCube/borderSize);
	}
	
	float sdOctahedronBound( in vec3 p, in float s)
	{
		p = abs(p);
		return (p.x+p.y+p.z-s)*0.57735027;
	}
	
	float sdOctahedronExact( in vec3 p, in float s)
	{
		p = abs(p);
		float m = p.x+p.y+p.z-s;
		vec3 q;
			 if( 3.0*p.x < m ) q = p.xyz;
		else if( 3.0*p.y < m ) q = p.yzx;
		else if( 3.0*p.z < m ) q = p.zxy;
		else return m*0.57735027;
		
		float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
		return length(vec3(q.x,q.y-s+k,q.z-k)); 
	}
	
	float sdfFunc(in vec4 position){
		float mbSdf = mbSdfFunc(position);
		//return mbSdf;	//retain earlier behaviour, no player object 
		
		/*
		//get some new sdffunc for a player object
		float playerSdf = length(position.xyz - vec3(8.0,0.0,0.0)) - 1.0;
		return min(mbSdf,playerSdf);
		*/
		
		//pyramid player object.
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		//return min(mbSdf,playerSdf);
		
		float toReturnSdf = min(mbSdf,playerSdf);
		toReturnSdf= min(toReturnSdf, sdOctahedronBound(position.xyz - vec3(-8.0,0.0,2.0) ,1.0));
		toReturnSdf= min(toReturnSdf, sdOctahedronExact(position.xyz - vec3(-8.0,0.0,-2.0) ,1.0));
		
		return toReturnSdf;
	}
	
	void main(void){
		scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
		
		C2 = pow(abs(SCALE), float(1-ITERS));
	
		float cubsdf=-100.0;	// not sure what to initialise.. maybe should actually be storing/comparing sdf/z ? 
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
				
		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		float previousSdf;
		for (int ii=0;ii<RAYSTEPSI;ii++){
			previousSdf = cubsdf;
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			//if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
		
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){	//slightly smoother shading (for numsteps). requires greater numsteps of black spot artifact for surface pointed at camera.
								//should be able to use this for better depth estimation with fewer steps too. (basically using exponential decay towards flat surface)
				numSteps=float(ii);
				if (cubsdf<previousSdf){
					numSteps+=log2(RAYTERMINCOND*inCameraFrameZ/previousSdf)/log2(cubsdf/previousSdf);	//guessing...
				}
				break;
			}
			
			//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		
		return;
		//override with debug rendering
		gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		gl_FragColor.y = lightval;	//doesn't seem to be working right. is surface finding reliable?
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}

</script>



<!-- fragment shader -->
<!-- mandelbox copy paste from forum-->
<script id="shader-raymarch9a-fs" type="x-shader/x-fragment">
	//version with uniforms instead of literals using define

	//basically copied from Rrola's code here http://www.fractalforums.com/3d-fractal-generation/a-mandelbox-distance-estimate-formula/15/
	//picked that because alter in thread, guess better optimised than earlier.

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.001
	
	#define ITERS 24
	#define MR2 0.16
	
	precision mediump float;
	
	uniform float uMandelboxScale;
	uniform float uC1;
	uniform float uCubeLimit;
	uniform float uCamCurve;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	vec4 scalevec;
	float C2;	//guess faster to hard code than calculate in main;

	float mbSdfFunc(in vec4 position){
		//should calculate halflength outside (eg by define or uniform)
		vec3 distFromSides = max(abs(position.xyz) - uCubeLimit , 0.0);

		float distFromCube = length(distFromSides);
		
		float borderSize = 0.5;
		if (distFromCube>borderSize){return distFromCube;}
		distFromCube=max(distFromCube,0.0);	//to use as a blend factor to make continuous SDF
		
	  // distance estimate
	  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
	  for (int i=0; i<ITERS; i++) {	//hard coded iters? can set by define?
		p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3
		float r2 = dot(p.xyz, p.xyz);  // dp3
		p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
		p.xyzw = p*scalevec + p0;  // mad4
	  }
		
	  //return (length(p.xyz) - C1) / p.w - C2;
	  
	  //make sdf func continuous to reduce banding in num steps ?
	  float unmodifiedSdf = (length(p.xyz) - uC1) / p.w - C2;
	  return mix(unmodifiedSdf,distFromCube,distFromCube/borderSize);
	}
	
	float sdOctahedronBound( in vec3 p, in float s)
	{
		p = abs(p);
		return (p.x+p.y+p.z-s)*0.57735027;
	}
	
	float sdOctahedronExact( in vec3 p, in float s)
	{
		p = abs(p);
		float m = p.x+p.y+p.z-s;
		vec3 q;
			 if( 3.0*p.x < m ) q = p.xyz;
		else if( 3.0*p.y < m ) q = p.yzx;
		else if( 3.0*p.z < m ) q = p.zxy;
		else return m*0.57735027;
		
		float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
		return length(vec3(q.x,q.y-s+k,q.z-k)); 
	}
	
	float sdfFunc(in vec4 position){
		float mbSdf = mbSdfFunc(position);
		//return mbSdf;	//retain earlier behaviour, no player object 
		
		/*
		//get some new sdffunc for a player object
		float playerSdf = length(position.xyz - vec3(8.0,0.0,0.0)) - 1.0;
		return min(mbSdf,playerSdf);
		*/
		
		//pyramid player object.
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		//return min(mbSdf,playerSdf);
		
		float toReturnSdf = min(mbSdf,playerSdf);
		toReturnSdf= min(toReturnSdf, sdOctahedronBound(position.xyz - vec3(-8.0,0.0,2.0) ,1.0));
		toReturnSdf= min(toReturnSdf, sdOctahedronExact(position.xyz - vec3(-8.0,0.0,-2.0) ,1.0));
		
		return toReturnSdf;
	}
	
	void main(void){
		scalevec = vec4(vec3(uMandelboxScale), abs(uMandelboxScale)) / MR2;
		
		C2 = pow(abs(uMandelboxScale), float(1-ITERS));
	
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
				
		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		
		return;
		//override with debug rendering
		gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		gl_FragColor.y = lightval;	//doesn't seem to be working right. is surface finding reliable?
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}
</script>



<!-- a cone tracer (this is still a raymarcher, not a cone marcher. cone and raymarchers are usually sphere tracers)
basically would like to raymarch a surface texture, using an image texture. webgl1 doesn't support 3d textures, and would need to create them anyway
idea is that if have some heightmap with a maximum gradient, then a conical tip with this gradient can touch the surface at any point. therefore can march within this cone. easy enough to test - just find the maximum gradient between any 2 pixels in the heightmap. (of order numpix) to get decent perf, should be pretty shallow. sand dunes texture maybe good for this.
further optimisations?
1) for looking angles steeper than max gradient, know will pass thru once. therefore might march further (eg with expectation surface is flat, ie twice "safe" distance.
2) encode a cone angle (side steepness) along with the height in the map. requires more work at texture generation stage -  obvious auto-generation approach straightforward but slow ( order numpix^2 ). downside that need extra channel- not just using alpha channel for rgb texture or normalmap (normalmap maybe 2d is enough...)
3) might (ab)use normal map- what's the widest cone aligned with normal that touches surface. maybe requires checking that such a cone exists! (does the ray exist?). maybe this not good- generally problem parts (that cause a lot of marches) are bits at top for ray skimming over, trivially, cone surface can't "go down" because assume surface repeats etc.
4) ensure that surface hits bounding top plane frequently. therefore 6 should work well
5) some more flexible bounding shape (while simple to calculate how far to march. cone+parabola? again more work at generation time. 
6) starting at upper limit plane of surface should save many iterations.
	basically take max of collision distance along ray for plane, sdf. should happen only one time rather than being in sdffunc. unnecessary if bounded by geometry,  
		
maybe has downside that will be harder to use conemarching for perf boost (vs quite neat in sphere tracer)

initially can just do this for a virtual texture lookup - eg array of pyramids. should compare perf to spheretracer
can get an effective sdf using this if have ray direction info

eventually might wish to combo with "real" geometry so webgl default depth mapping works, and to reduce filled pixels.


step1- a surface spheremarcher with a max gradient which should be reproducible using conetracing/virtual height map
-->
<script id="shader-raymarch-wobble-strace-fs" type="x-shader/x-fragment">

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.0002
	
	precision mediump float;
	
	uniform float uCamCurve;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	float pyramidSurfSdf(in vec4 position){
		//initially simple surface
	//	return position.y+10.0;	//+10.0 pushes surface down by 10
		
		//super simple surface - shallow sine wave. spheres aren't quite right - will be very wrong if sine wave steep
		
		return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		//return 0.85*(position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4));	//remove artifacts - really should be a better method to get sdf for sine waves. (look it up!)
	}
	
	float sdfFunc(in vec4 position){
		//pyramid player object.
		
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		
		return min(playerSdf, pyramidSurfSdf(position));
	}
	
	void main(void){
		float cubsdf=100000000.0;	//initialise some smthg since doing previousSdf (should be big. not zero because dividing by...)
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??

		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		//first, big step to upper bound of surface.
		//todo make this switchable/alternate shader, to demo that range already better than sphere tracer
		//since return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		//min alt means highest surf . position.y +10 -1-1 = position.y+8
		//ie surf is at y=-8
		//this helps range hugely, but doesn't play nice with other object in scene (player pyramid)
		//could make this check part of regular raymarch (step is max of conetrace and this calculation)
		if (rayDir.y<0.0){
			//going downward.
			if (rayPos.y>-8.0){
				rayPos-=rayDir*((rayPos.y+8.0)/rayDir.y);
			}
		}
		
		
		
		float previousSdf;
		for (int ii=0;ii<RAYSTEPSI;ii++){
			previousSdf = cubsdf;
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.0005;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		//rayPos+=vec4(0.0,smallDisp,0.0,0.0);
		rayPos+=vec4(smallDisp,0.0,0.0,0.0); 	//light from side instead of straight down!		
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		//gl_FragColor = vec4(vec3(mycol,mycol,mycol*mycol)*lightval,1.0);
		gl_FragColor = vec4(vec3(lightval),1.0);
		return;
		//override with debug rendering
		//gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		//gl_FragColor.x = 0.0;	
		gl_FragColor.x = mod(rayPos.y,1.0);
		gl_FragColor.y = lightval;
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}


</script>


<!-- "cone tracer" equivalent of above-->
<script id="shader-raymarch-wobble-ctrace-fs" type="x-shader/x-fragment">

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.0002
	
	precision mediump float;
	
	uniform float uCamCurve;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	float pyramidSurfAltitude(in vec4 position){
		//initially simple surface
	//	return position.y+10.0;	//+10.0 pushes surface down by 10
		
		//super simple surface - shallow sine wave. 
		return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		
		//what is maximum gradient? 
		//derivative of sin(kx) = ksinx . k=0.4 so max grad 0.4
		//in 2 directions so 0.4*sqrt(2) = 0.56568
	}
	
	float marchFactor;
	
	float pyramidSurfMarchdist(in vec4 position){
		return marchFactor*pyramidSurfAltitude(position);	
		
		//assume some cone angle. initially try 45 degrees. 
		//this should be precalculated since rayDir does not change. basically mapping alt to march distance. 
		// for vertical, dist = alt
		// for some cone angle... - dot(rayDir,conenorm) , which is, assuming cone normal in y direction
		//   length(rayDir.xz)*coneOutNorm + rayDir.y*coneDownNorm
		//	ray length scales as 1/that . to get correct scale constant, see that for ray pointing down:
		// that = 1*coneDownNorm.
		// therefore just make the cone normal not normalised. coneDownNorm = -1, coneOutNorm is cone gradient. ie for 45 deg, coneoutnorm=1.
		
		//therefore
		// marchlength = alt / (length(rayDir.xz)*coneGrad - rayDir.y )
		// 
		//sensible to precalc marchFactor = 1/(length(rayDir.xz)*coneGrad - rayDir.y )
			// then marchlength = alt*marchfactor
			//note that marchfactor can be inf! guess should account for that earlier. hack to make work by just doing
			//marchFactor = 1/max(smallPositiveNumber,(length(rayDir.xz)*coneGrad - rayDir.y ))
			//really though should just be returning early
	}
	
	float sdfFunc(in vec4 position){
		//pyramid player object.
		
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		
		return min(playerSdf, pyramidSurfMarchdist(position));
	}
	
	void main(void){
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??

		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		

		float coneGrad=0.56568;	//AFAIK exact limiting gradient
		//float coneGrad=0.1;	//too shallow. expect artifacts
		marchFactor = 1.0/max(0.000001,(length(rayDir.xz)*coneGrad - rayDir.y ));
		
		
		
		//first, big step to upper bound of surface.
		//todo make this switchable/alternate shader, to demo that range already better than sphere tracer
		//since return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		//min alt means highest surf . position.y +10 -1-1 = position.y+8
		//ie surf is at y=-8
		//this helps range hugely, but doesn't play nice with other object in scene (player pyramid)
		//could make this check part of regular raymarch (step is max of conetrace and this calculation)
		if (rayDir.y<0.0){
			//going downward.
			if (rayPos.y>-8.0){
				rayPos-=rayDir*((rayPos.y+8.0)/rayDir.y);
			}
		}
		
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.0005;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
	/*														
		//rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		rayPos+=vec4(smallDisp,0.0,0.0,0.0); 	//light from side instead of straight down!
			//TODO check logic holds up for cone-tracer normal esitmation!
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		//float lightval = (distanceDifference/smallDisp)*0.5/marchFactor+0.5;	//map -1 to 1 to 0 to 1
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
			//adding the 1/marchfactor appears to fix lighting difference between sphere and cone tracing. (bit annoying for mixed scenes)
	*/		
		//what is exact thing here? lighting vector = displacement vector d.
		//easiest way maybe just to create normal by 2 displacements in x,z.
		//maybe can get to work by single sample method...
		
		//change in sampled value = d.x*(dy/dx) + d.z*(dy/dz) - d.y = dot(d, vec3(dy/dx, -1, dy/dz))
		//normal to surface - when viewed from side should be perpendicular to line, so:
		// n.x/n.y = -dy/dx , n.z/n.y = -dy/dz 
		// -> n = normalize ( -dy/dx , 1, -dy/dz)
		//	-> light = -d.norm = dot(d,normalize ( dy/dx , -1, dy/dz))
		
		// -> lighting different to difference of samples, because normalisation.
		// in example of lighting along x, know that...
		// change in sampled value = d.x(dy/dx)	=	dy/dx
		// light = d.x((dy/dx)/length(dy/dx,-1,dy/dz)
		//	but don't know the length!
		
		//seems that to get correct normal, require two displaced samples. (x,z displaced)
		
		float dydx = cubsdf - sdfFunc(rayPos+vec4(smallDisp,0.0,0.0,0.0));
		float dydz = cubsdf - sdfFunc(rayPos+vec4(0.0,0.0,smallDisp,0.0));
		vec3 normal = normalize(vec3(dydx,smallDisp,dydz));
		float lightval2 = dot(vec3(1.,0.,0.),  normal);
		//map -1 to 1 -> 0 to 1
		float lightval = -lightval2*0.5 + 0.5;
			//^  doesn't seem much difference to guessed hack method
		
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		//gl_FragColor = vec4(vec3(mycol,mycol,mycol*mycol)*lightval,1.0);
		gl_FragColor = vec4(vec3(lightval),1.0);
		return;
		//override with debug rendering
		//gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		//gl_FragColor.x = 0.0;
		gl_FragColor.x = mod(rayPos.y,1.0);
		gl_FragColor.y = lightval;
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}


</script>


<!-- cone tracer that uses a max func to handle combining other object with surface, avoiding simple step to bounding surface -->
<script id="shader-raymarch-wobble-ctrace2-fs" type="x-shader/x-fragment">

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.0002
	
	precision mediump float;
	
	uniform float uCamCurve;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	float pyramidSurfAltitude(in vec4 position){
		//initially simple surface
	//	return position.y+10.0;	//+10.0 pushes surface down by 10
		
		//super simple surface - shallow sine wave. 
		return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		
		//what is maximum gradient? 
		//derivative of sin(kx) = ksinx . k=0.4 so max grad 0.4
		//in 2 directions so 0.4*sqrt(2) = 0.56568
	}
	
	float marchFactor;
	
	float pyramidSurfMarchdist(in vec4 position){
		return marchFactor*pyramidSurfAltitude(position);	
		
		//assume some cone angle. initially try 45 degrees. 
		//this should be precalculated since rayDir does not change. basically mapping alt to march distance. 
		// for vertical, dist = alt
		// for some cone angle... - dot(rayDir,conenorm) , which is, assuming cone normal in y direction
		//   length(rayDir.xz)*coneOutNorm + rayDir.y*coneDownNorm
		//	ray length scales as 1/that . to get correct scale constant, see that for ray pointing down:
		// that = 1*coneDownNorm.
		// therefore just make the cone normal not normalised. coneDownNorm = -1, coneOutNorm is cone gradient. ie for 45 deg, coneoutnorm=1.
		
		//therefore
		// marchlength = alt / (length(rayDir.xz)*coneGrad - rayDir.y )
		// 
		//sensible to precalc marchFactor = 1/(length(rayDir.xz)*coneGrad - rayDir.y )
			// then marchlength = alt*marchfactor
			//note that marchfactor can be inf! guess should account for that earlier. hack to make work by just doing
			//marchFactor = 1/max(smallPositiveNumber,(length(rayDir.xz)*coneGrad - rayDir.y ))
			//really though should just be returning early
	}
	
	float sdfFunc(in vec4 position, float ydir){
		//pyramid player object.
		
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		
				
		float toBoundingSurf=-1000.;	//will pick maximum. make smaller than 0 because should be able to return something -ve when doing displacement check for normals.
		if (position.y>-8.){
			if (ydir<0.){	//going downward.
				toBoundingSurf = -(position.y+8.)/ydir;
			}
		}
		//^^ better to calc a collision rayPos.w value?
		
		return min(playerSdf, max(pyramidSurfMarchdist(position),toBoundingSurf));
	}
	
	void main(void){
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??

		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		

		float coneGrad=0.56568;	//AFAIK exact limiting gradient
		//float coneGrad=0.1;	//too shallow. expect artifacts
		marchFactor = 1.0/max(0.000001,(length(rayDir.xz)*coneGrad - rayDir.y ));
		
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos, rayDir.y);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00005;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		//rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		rayPos+=vec4(smallDisp,0.0,0.0,0.0); 	//light from side instead of straight down!
			//TODO check logic holds up for cone-tracer normal esitmation!
		
		float distanceDifference = sdfFunc(rayPos, rayDir.y) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5/marchFactor+0.5;	//map -1 to 1 to 0 to 1	THIS CAN BE A BIT WRONG!!
		//float lightval = (distanceDifference/smallDisp)*0.5*0.01+0.5;	//map -1 to 1 to 0 to 1	THIS CAN BE A BIT WRONG!!
			//adding the 1/marchfactor appears to fix lighting difference between sphere and cone tracing. (bit annoying for mixed scenes)
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		//gl_FragColor = vec4(vec3(mycol,mycol,mycol*mycol)*lightval,1.0);
		gl_FragColor = vec4(vec3(lightval),1.0);
		return;
		//override with debug rendering
		//gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		//gl_FragColor.x = 0.0;
		gl_FragColor.x = mod(rayPos.y,1.0);
		gl_FragColor.y = lightval;
		//gl_FragColor.y = .5;
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}
</script>


<!-- "cone tracer" with a different scene-->
<script id="shader-raymarch10b-fs" type="x-shader/x-fragment">

	#define RAYSTEPSI 24
	#define RAYSTEPSF 24.0
	#define RAYTERMINCOND 0.001
	
	precision mediump float;
	
	uniform float uCamCurve;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	float pyramidSurfAltitude(in vec4 position){
		//initially simple surface
	//	return position.y+10.0;	//+10.0 pushes surface down by 10
		
		//super simple surface - shallow sine wave. 
		//return position.y+10.0+sin(position.x*0.4)+sin(position.z*0.4);
		
		return position.y+10.0+max(abs(mod(position.x*0.5656,4.0)-2.0), abs(mod(position.z*0.5656,4.0)-2.0));
		
		//what is maximum gradient? 
		//derivative of sin(kx) = ksinx . k=0.4 so max grad 0.4
		//in 2 directions so 0.4*sqrt(2) = 0.56568
	}
	
	float marchFactor;
	
	float pyramidSurfMarchdist(in vec4 position){
		return marchFactor*pyramidSurfAltitude(position);	
		
		//assume some cone angle. initially try 45 degrees. 
		//this should be precalculated since rayDir does not change. basically mapping alt to march distance. 
		// for vertical, dist = alt
		// for some cone angle... - dot(rayDir,conenorm) , which is, assuming cone normal in y direction
		//   length(rayDir.xz)*coneOutNorm + rayDir.y*coneDownNorm
		//	ray length scales as 1/that . to get correct scale constant, see that for ray pointing down:
		// that = 1*coneDownNorm.
		// therefore just make the cone normal not normalised. coneDownNorm = -1, coneOutNorm is cone gradient. ie for 45 deg, coneoutnorm=1.
		
		//therefore
		// marchlength = alt / (length(rayDir.xz)*coneGrad - rayDir.y )
		// 
		//sensible to precalc marchFactor = 1/(length(rayDir.xz)*coneGrad - rayDir.y )
			// then marchlength = alt*marchfactor
			//note that marchfactor can be inf! guess should account for that earlier. hack to make work by just doing
			//marchFactor = 1/max(smallPositiveNumber,(length(rayDir.xz)*coneGrad - rayDir.y ))
			//really though should just be returning early
	}
	
	float sdfFunc(in vec4 position){
		//pyramid player object.
		
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		
		return min(playerSdf, pyramidSurfMarchdist(position));
	}
	
	void main(void){
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??

		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		
		//first, big step to upper bound of surface.
		//todo make this switchable/alternate shader, to demo that range already better than sphere tracer
		// return position.y+10.0+max(abs(mod(position.x*0.5656,4.0)-2.0), abs(mod(position.z*0.5656,4.0)-2.0));
		
		if (rayDir.y<0.0){
			//going downward.
			if (rayPos.y>-10.0){
				rayPos-=rayDir*((rayPos.y+10.0)/rayDir.y);
			}
		}
		
		
		float coneGrad=0.56568;	//AFAIK exact limiting gradient
		//float coneGrad=0.1;	//too shallow. expect artifacts
		marchFactor = 1.0/max(0.000001,(length(rayDir.xz)*coneGrad - rayDir.y ));
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.0004;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		//rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		rayPos+=vec4(smallDisp,0.0,0.0,0.0); 	//light from side instead of straight down!
			//TODO check logic holds up for cone-tracer normal esitmation!
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5/marchFactor+0.5;	//map -1 to 1 to 0 to 1
			//adding the 1/marchfactor appears to fix lighting difference between sphere and cone tracing. (bit annoying for mixed scenes)
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		gl_FragColor = vec4(vec3(mycol,mycol,mycol*mycol)*lightval,1.0);
		
		//return;
		//override with debug rendering
		gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		//gl_FragColor.x = 0.0;
		gl_FragColor.y = lightval;
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}


</script>


<!-- "cone tracer" with texture lookup-->
<script id="shader-raymarch11-fs" type="x-shader/x-fragment">
	//this is super slow, maybe because texture reads are dependent on eachother, or maybe tex reads just slow
	//candidate for speedup by lo-hi resolution stages ?
	

	#define RAYSTEPSI 24
	#define RAYSTEPSF 24.0
	#define RAYTERMINCOND 0.001
	
	precision mediump float;
	
	uniform float uCamCurve;
	uniform sampler2D uSampler;
	
	varying vec3 mynum;
	varying vec3 rayStart;
	varying vec3 vCameraDirection;
	
	float pyramidSurfAltitude(in vec4 position){
		return position.y+10.0-4.0*texture2D(uSampler, position.xz*0.015).x;
	}
	
	float marchFactor;
	
	float pyramidSurfMarchdist(in vec4 position){
		return marchFactor*pyramidSurfAltitude(position);	
	}
	
	float sdfFunc(in vec4 position){
		//pyramid player object.
		
		vec3 psnPlayerFrame = position.xyz - vec3(8.0,0.0,0.0);
		vec2 absPlayerXY = abs(psnPlayerFrame.xy);
		//float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*0.7 + psnPlayerFrame.z*0.7 - 1.0;	//0.7 should be root 2
		float pyramidAng = 0.3;
		float playerSdf = max(absPlayerXY.x,absPlayerXY.y)*cos(pyramidAng) + psnPlayerFrame.z*sin(pyramidAng) - 1.0;	//pointier
			//at this stage, infinite pyramid!
		playerSdf = max(playerSdf , 1.0-psnPlayerFrame.z);
		
		return min(playerSdf, pyramidSurfMarchdist(position));
	}
	
	void main(void){
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??

		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//variable camera rectilinear to stereographic, maintaining fixed angular res in centre of view. unoptimised code.
		float var1 = uCamCurve*-0.125;
		float var2 = 4.0;	//zoom
		float mynumdotcamdir = dot(vCameraDirection,mynum);
		vec3 plllpart = mynumdotcamdir*vCameraDirection;
		vec3 perppart = mynum - plllpart;
		float zpos = 2.0 + var1*(var2*var2*dot(perppart,perppart));
		vec4 rayDir = vec4( normalize(var2*perppart + zpos*vCameraDirection), 1.0);
		
		
		//quick step to upper bounding plane (see previous shaders)
		if (rayDir.y<0.0){
			//going downward.
			//float planeBound = -8.5;	//seems sand heightmap doesn't go all the way to white
			float planeBound = -6.;
			if (rayPos.y>planeBound){
				rayPos-=rayDir*((rayPos.y-planeBound)/rayDir.y);
			}
		}
		
		//float coneGrad=0.7;	//trial and error it for now. bigger safer and slower
		float coneGrad=1.0;	//trial and error it for now. bigger safer and slower

		marchFactor = 1.0/max(0.000001,(length(rayDir.xz)*coneGrad - rayDir.y ));
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.w;	//TODO some multiplier for this const for a given pixel
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.1;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
									//make bigger because constant gradient across pixel
															
		//rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		rayPos+=vec4(smallDisp,0.0,0.0,0.0); 	//light from side instead of straight down!
			//TODO check logic holds up for cone-tracer normal esitmation!
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5/marchFactor+0.5;	//map -1 to 1 to 0 to 1
			//adding the 1/marchfactor appears to fix lighting difference between sphere and cone tracing. (bit annoying for mixed scenes)
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		gl_FragColor = vec4(vec3(mycol,mycol,mycol*mycol)*lightval,1.0);
		
		return;
		//override with debug rendering
		gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		//gl_FragColor.x = 0.0;
		gl_FragColor.y = lightval;
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}
</script>


<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="data/quad.js"></script>

<script type="text/javascript">
/*
basic raymarcher test
initially just an array of cubes, no camera transform
get webgl boilerplate working

then can look at
* multiple scenes (different shaders)
* camera transformation (including ortho. the ray start point can be a varying, and might be varying for persp too if choose a near clip plane)
* speedup by changnig termination condition (basically size of pixel at given distance, but 
* speedup by shooting blocks (cones for perspective camera) and rendering series of increasing resolution depth maps
* fractals!
* consistent alternate version where raymarching shader is applied to surface of an object eg a cube that surrounds the object described by SDF (eg mandelbox), transformed in the vertex shader. (for use in hybrid renderer / to draw fewer pixels)
* hybrid version in scene with pther objects
* shadows
* hybrid shadows?
* etc, etc!
* having SDF and raymarcher in copy accessible to js code too, for collision. 
* using this to implement say, sphere player collider
* normals (derivative of SDF) for rendering and collision response (bounce/ friction?)

*/

var shaderPrograms={};
function initShaders(){
	//shaderProgramFlat = loadShader( "shader-fullscreen-vs", "shader-flatcolor-fs",{
	var standardAttributes = ["aVertexPosition"];
	var standardUniforms = ["uMVMatrix","fovScale","rayStartIn","uCamCurve"];
	shaderPrograms.tori = loadShader( "shader-fullscreen-vs", "shader-raymarch6-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.mengercubes = loadShader( "shader-fullscreen-vs", "shader-raymarch8-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.mengercubes_equirect = loadShader( "shader-fullscreen-equirect-vs", "shader-raymarch8-equirect-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	
	shaderPrograms.mandelbox = loadShader( "shader-fullscreen-vs", "shader-raymarch9-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.mandelboxConfigurable = loadShader( "shader-fullscreen-vs", "shader-raymarch9a-fs",{
					attributes:standardAttributes,
					uniforms:["uMVMatrix","fovScale","rayStartIn","uCamCurve","uMandelboxScale","uC1","uCubeLimit"]
					});
	shaderPrograms.wobblySurfaceSphereTracer = loadShader( "shader-fullscreen-vs", "shader-raymarch-wobble-strace-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.wobblySurfaceConeTracer = loadShader( "shader-fullscreen-vs", "shader-raymarch-wobble-ctrace-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.wobblySurfaceConeTracer2 = loadShader( "shader-fullscreen-vs", "shader-raymarch-wobble-ctrace2-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.pyramidSurfaceConeTracer = loadShader( "shader-fullscreen-vs", "shader-raymarch10b-fs",{
					attributes:standardAttributes,
					uniforms:standardUniforms
					});
	shaderPrograms.textureConeTracer = loadShader( "shader-fullscreen-vs", "shader-raymarch11-fs",{
					attributes:standardAttributes,
					uniforms:["uMVMatrix","fovScale","rayStartIn","uCamCurve","uSampler"]
					});
}


var texture;

function initTexture(){
	//texture = makeTexture("data/terrain/turbulent-seamless.png");
	//texture = makeTexture("data/terrain/seamless_tileable_voronoi_bump_displacement_map_by_mcasual_dbr4tgs.png");
	texture = makeTexture("data/terrain/filterforge-jaggedrock.jpg");
}

function makeTexture(src) {	//to do OO
	var texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function(){
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		//gl.generateMipmap(gl.TEXTURE_2D);		//not sure how mipmapping will work out with multiple samples from same texture for a given pixel
		gl.bindTexture(gl.TEXTURE_2D, null);
	};	
	texture.image.src = src;
	return texture;
}

var quadBuffers={};

function initBuffers(){

	loadBufferData(quadBuffers, quadData);

	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
		console.log("buffered. numitems: " + buffer.numItems);
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
		//stuff about normals etc present in 3-sph project got this from, removed here. 
		
		//triangles rather than strip, but no big deal- frag shader does most of the work!
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
}


//copied from 3sphere project. much of this unused since objs here don't have normals, textures
function drawObjectFromBuffers(bufferObj, shaderProg, usesCubeMap){
	prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	/*
	if (bufferObj.vertexNormalBuffer && shaderProg.attributes.aVertexNormal){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	*/
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	/*
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	
	if (usesCubeMap){
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	*/
	//gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

var textureEnabled=false;
function drawScene(){
	stats.end();
	stats.begin();

	var sizefactor = 1;
	if (shouldTakeScreenshot){sizefactor=4;}
	resizecanvas(sizefactor);	//1 for same resolution as displayed. larger number to draw more pixels, observe slowdown on a decent machine
						//4 and things break on vivaldi!
	
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	//TODO should this be every frame?

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var activeShaderProgram = shaderPrograms[guiParams.shader];
	gl.useProgram(activeShaderProgram);
	
	//this probably should only be happening on shader switching:
	//also maybe should be deactivating texture when not in use
	if(activeShaderProgram.uniforms.uSampler){
		enableTexture(true);
	}else{
		enableTexture(false);
	}
	
	//this should change if multiple shaders use a texture.
	function enableTexture(shouldEnable){		//bug:tex takes time to load, so thinks enabled when not...
		if (shouldEnable!=textureEnabled){
			if(shouldEnable){
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.uniform1i(activeShaderProgram.uniforms.uSampler, 0);
			}else{
				gl.bindTexture(gl.TEXTURE_2D, null);
			}
		}
		textureEnabled=shouldEnable;
	}
	
	if (Object.keys(activeShaderProgram.uniforms).indexOf("uMandelboxScale")!=-1){
		var mbScale = guiParams.absMandelboxScale * guiParams.signMandelboxScale;
		//console.log(mbScale);
		gl.uniform1f(activeShaderProgram.uniforms.uMandelboxScale, mbScale);
		gl.uniform1f(activeShaderProgram.uniforms.uC1,Math.abs(mbScale-1));
		gl.uniform1f(activeShaderProgram.uniforms.uCubeLimit, (mbScale<0) ? 2: 2*(mbScale+1)/(mbScale-1));	//strange. -ve is always smaller than +ve. bug?
	}
	
	gl.uniform1f(activeShaderProgram.uniforms.uCamCurve, guiParams.camCurve);
	
	//For scale < -1 the mandelbox sides have length 4 and for 1 < scale <= 4?n+1 they have length 4(scale+1)/(scale-1)
	// what is n ? assuming condition correct (at least, n>=1) 
	
	// scale 1 , length 4(2/0)	-> inf!
	// scale 1.5, length 4(2.5/0.5) -> 20			half length =10
	// scale 1.75, length 4(2.75/0.75) -> 14.666	half length 7.333
	// scale 2 , length 4(3/1)  -> 12				half length =6
	// scale 2.5, length 4(3.5/1.5) -> 9.333		half length = 4.666
	// scale 3 , length 4(4/2) -> 8					half length =4
	// scale 4, length 4(5/3) -> 6.6666				half length = 3.333
	
	
	gl.uniform3fv(activeShaderProgram.uniforms.fovScale, [gl.viewportWidth/gl.viewportHeight,1,1]);
	//gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,Math.random()]);
	//gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,(new Date()).getTime()*0.0005 % 4]);
	gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, camPos);
	
	var topBottom = true;	//for stereo rendering.
	if (!topBottom){
		drawObjectFromBuffers(quadBuffers, activeShaderProgram);
	}else{
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight/2);
		drawObjectFromBuffers(quadBuffers, activeShaderProgram);
		gl.viewport(0,  gl.viewportHeight/2, gl.viewportWidth, gl.viewportHeight/2);
		drawObjectFromBuffers(quadBuffers, activeShaderProgram);
	}
	
	if (shouldTakeScreenshot){
		console.log("will try to take a screenshot");
		downloadCanvas("savedCanvas.png","png",canvas);	//this approach appears to use too much memory
		shouldTakeScreenshot=false;
	}
	
}

//first get a gl window with some clearcolor

var camPos = [10,0,-5];
var mvMatrix = mat4.create();
mat4.identity(mvMatrix);

var mouseInfo = {
	x:0,
	y:0,
	dragging: false,
	lastPointingDir:{},
	currentPointingDir:{x:0,y:0,z:1,w:1}
};

var guiParams={};



function init(){
	
	var iterateMechanics = (function generateIterateMechanics(){
		var newTime = (new Date()).getTime();
		var camSpeed = [0,0,0];
		
		window.addEventListener("keydown",function(e){
			var keyCode=e.keyCode;
			console.log(keyCode);
			//WASD = 87,65,83,68
			var camStep = 0.001;
			
			var camMove = [0,0,0];
			if (keyCode == 87){camMove[2]+=camStep;}
			if (keyCode == 83){camMove[2]-=camStep;}
			if (keyCode == 65){camMove[0]-=camStep;}
			if (keyCode == 68){camMove[0]+=camStep;}
			
			/*
			//move camPos in camera direction. TODO just use mvMatrix.
			//probably neater way to do this, but
			camPos[0] += camMove[0]*mvMatrix[0] + camMove[1]*mvMatrix[4] + + camMove[2]*mvMatrix[8];
			camPos[1] += camMove[0]*mvMatrix[1] + camMove[1]*mvMatrix[5] + + camMove[2]*mvMatrix[9];
			camPos[2] += camMove[0]*mvMatrix[2] + camMove[1]*mvMatrix[6] + + camMove[2]*mvMatrix[10];
			*/
			
			//add to camSpeed instead
			camSpeed[0] += camMove[0]*mvMatrix[0] + camMove[1]*mvMatrix[4] + + camMove[2]*mvMatrix[8];
			camSpeed[1] += camMove[0]*mvMatrix[1] + camMove[1]*mvMatrix[5] + + camMove[2]*mvMatrix[9];
			camSpeed[2] += camMove[0]*mvMatrix[2] + camMove[1]*mvMatrix[6] + + camMove[2]*mvMatrix[10];
			
			var rollSpd = 0.02;
			var rollAmt = 0;
			if (keyCode == 69){rollAmt-=rollSpd;}
			if (keyCode == 81){rollAmt+=rollSpd;}
			rotatePlayer([0,0,rollAmt]);
		});
		
		return function(){
			var oldTime = newTime;
			newTime = (new Date()).getTime();
			var timeElapsed = Math.min(newTime - oldTime, 1000);	//1s max
			//exponential decay of speed towards desired speed. TODO proper movement integration, but doesn't really matter
			var decayFactor = Math.pow(0.995,timeElapsed);
			
			camSpeed = camSpeed.map(function(val,ii){return val*decayFactor;});	//TODO keystate = target value... + (1-decayFactor)*camMove[ii];});
			//camSpeed = camSpeed.map(function(val,ii){return camMove[ii];});
			camPos = camPos.map(function(val,ii){return val+timeElapsed*camSpeed[ii];});
			//camPos = camPos.map(function(val,ii){return val;});
		}
	})();
	

	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );
	
	canvas = document.getElementById("mycanvas");
	
	//mouse code copied from 3sphere-explorer
	canvas.addEventListener("mousedown", function(evt){
		mouseInfo.x = evt.offsetX;
		mouseInfo.y = evt.offsetY;
		mouseInfo.dragging = true;
		mouseInfo.lastPointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
	});
	canvas.addEventListener("mouseup", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mouseout", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mousemove", function(evt){
		mouseInfo.currentPointingDir = getPointingDirectionFromScreenCoordinate({x:evt.offsetX, y: evt.offsetY});
		if (mouseInfo.dragging){
			var pointingDir = mouseInfo.currentPointingDir;
			//console.log("pointingDir = " + pointingDir);
			
			//get the direction of current and previous mouse position.
			//do a cross product to work out the angle rotated
			//and rotate the player by this amount
			
			var crossProd = crossProductHomgenous(pointingDir, mouseInfo.lastPointingDir);
			mouseInfo.lastPointingDir = pointingDir;
			
			//rotate player 
			//guess have signs here because of unplanned handedness of screen, 3d co-ord systems
			//note switched some signs vs 3sphere-explorer version!
			var rotateAmt = [-crossProd.x / crossProd.w, crossProd.y / crossProd.w, -crossProd.z / crossProd.w];
			rotatePlayer(rotateAmt);
			
		}
	});
	function rotatePlayer(rotateAmt){
		//modify mvMatrix
		//glmatrix annoyingly takes an axis and angle, rather than axis*angle.
		//so have to do some bollocks
		var vecLength = rotateAmt.reduce(function(accumulator, currentValue){return accumulator + currentValue*currentValue;},0);
		vecLength=Math.sqrt(vecLength);
		var axis = rotateAmt.map(function(currentValue){return currentValue/vecLength;});

		mat4.rotate(mvMatrix,vecLength,axis);
	}
	
	initGL();
	
	//try clearing to green
	gl.clearColor.apply(gl,[0,1,0,1]);
	//gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	initShaders();
	initTexture();
	initBuffers();
	gl.disable(gl.DEPTH_TEST);
	
	var gui = new dat.GUI();
	var shadersList = Object.keys(shaderPrograms)
	
	guiParams['camCurve']=0.25;
	gui.add(guiParams,'camCurve',0,1,0.05);
	
	guiParams['shader']=shadersList[3];
	gui.add(guiParams,'shader',shadersList);

	guiParams['absMandelboxScale']=2;
	guiParams['signMandelboxScale']=1;
	
	gui.add(guiParams,'absMandelboxScale',1.5,6,0.1);
	gui.add(guiParams,'signMandelboxScale',[-1,1]);
	
	requestAnimationFrame(itMechanicsAndDrawScene);
	
	function itMechanicsAndDrawScene(){
		requestAnimationFrame(itMechanicsAndDrawScene);
		iterateMechanics();
		drawScene();
	}
	
	//to facilitate mouse drag to rotate (copied from 3sphere-explorer)
	//TODO have this work with a stereographic projection camera (or something inbetween)
	//should look at webgl-wideanglecamera project.
	var mainCamFov=90.0;	//TODO configurable FOV 
	
	function getPointingDirectionFromScreenCoordinate(coords){
		var maxyvert = 1.0;	
		var maxxvert = screenAspect;
		
		var xpos = maxxvert*(coords.x*2.0/gl.viewportWidth   -1.0 );
		var ypos = maxyvert*(coords.y*2.0/gl.viewportHeight   -1.0 );
		var radsq = xpos*xpos + ypos*ypos;
		var zpos = 1.0/Math.tan(mainCamFov*Math.PI/360); //TODO precalc

		//normalise - use sending back homogenous co-ords because maybe a tiny amount more efficient since cross producting anyway
		var mag= Math.sqrt(radsq + zpos*zpos);
		
		return {
			x: xpos,
			y: ypos,
			z: zpos,
			w: mag
		}
	}
	function crossProductHomgenous(dir1, dir2){
		var output ={};
		output.x = dir1.y * dir2.z - dir1.z * dir2.y; 
		output.y = dir1.z * dir2.x - dir1.x * dir2.z; 
		output.z = dir1.x * dir2.y - dir1.y * dir2.x;
		output.w = dir1.w * dir2.w;
		return output;
	}
}

var shouldTakeScreenshot = false;
function takeScreenshot(){
	//would like to render to an offscreen big canvas, save canvas to image file, but since gl context comes from screen canvas,
	//unsure if need another gl context. do have code elsewhere for drawing to image (to generate cubemap).
	//for now, just size screen big when take screenshot, save screen canvas.
	shouldTakeScreenshot=true;
}

function downloadCanvas(filename, fileext, canvastodownload){
	var data = canvastodownload.toDataURL("image/" + fileext);

	var pom = document.createElement('a');
    //pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    pom.setAttribute('href', data);
    pom.setAttribute('download', filename);

    if (document.createEvent) {
        var event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        pom.dispatchEvent(event);
    }
    else {
        pom.click();
    }
}



</script>
</head>

<body onload="init()">

<canvas id="mycanvas"></canvas>



</body>
</html>