<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>raymarcher test</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}
</style>

<!-- vertex shader with tex coords -->
<!-- start simple by just use 1 vec for ray direction. assume camera fixed at zero. likely should include matrix transformation for camera, pass through both ray start and direction as separate varying-->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	varying vec3 mynum;
	uniform vec3 fovScale;
	uniform vec3 rayStartIn;
	varying vec3 rayStart;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition,1.0);
		//mynum = 0.5*aVertexPosition.xy + 0.5;
		mynum = (aVertexPosition+vec3(0.0,0.0,1.0))*fovScale;	// z=1 for 90deg fov
		rayStart = rayStartIn;	//later for near plane or ortho camera, this will vary across camera view.
	}
</script>

<!-- fragment shader -->
<!-- super simple, just flat colour, then shade colour across image to check passing through vertex position stuff ok-->
<script id="shader-flatcolor-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		gl_FragColor = vec4(mynum.xy*0.5+0.5,0.0,1.0);
	}
</script>

<!-- fragment shader -->
<!-- single sphere raymarch-->
<script id="shader-raymarch1-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<10;ii++){
			//get distance estimate from rayPos
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(1.0-0.001*rayPos.w),1.0);
	}
</script>

<!-- fragment shader -->
<!-- square array spheres-->
<script id="shader-raymarch2-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<32;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy+2.0,4.0)-2.0;
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.00002*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres-->
<script id="shader-raymarch3-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch4-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			if (toSphere<0.02){numSteps=float(ii);break;}	//arbitary small number. 
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		gl_FragColor = vec4(vec3(max(0.0,1.0-numSteps/64.0)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch5-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			
			//rayPos = rayDir*rayPos.w;	//should have no effect
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.z){numSteps=float(ii)+(toSphere/(0.005*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array tori-->
<script id="shader-raymarch6-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		float toSphere;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toSphere = length(vec2(rad,toTorus.z)) -0.25;
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.z){numSteps=float(ii)+(toSphere/(0.005*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
			
			rayPos+=toSphere*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		toTorus = rayPos.xyz - theTorus;
		rad = length(toTorus.xy)-1.5;
		float distanceDifference = (length(vec2(rad,toTorus.z)) -0.25) - toSphere;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges-->
<script id="shader-raymarch7-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			
			/*
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toObject = length(vec2(rad,toTorus.z)) -0.25;
			*/
			toObjectVec = rayPos.xyz - theTorus;
			vec3 absVec = abs(toObjectVec);
			
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			
			cubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
			
			//chop smaller holes out (will do this iteratively)
			toObjectVec*=3.0;
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/3.0);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.z){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		
		//toTorus = rayPos.xyz - theTorus;
		//rad = length(toTorus.xy)-1.5;
		toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		maxxy = max(absVec.x,absVec.y);
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		
		float newcubsdf;
		newcubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
		
		//chop smaller holes out (will do this iteratively)
		toObjectVec*=3.0;
		toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
		absVec = abs(toObjectVec);
		maxxy = max(absVec.x,absVec.y);	//square hole
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		newcubsdf = max(newcubsdf , (0.25-minhole)/3.0);
		
		float distanceDifference = newcubsdf - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges , use function instead of copy/paste-->
<script id="shader-raymarch8-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
	
	float sdfFunc(inout vec4 rayPos){
		rayPos.xy =mod(rayPos.xy,4.0);
		//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
		rayPos.z =mod(rayPos.z,8.0);
		
		vec3 toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		//float cubsdf = max(absVec.z,maxxy)-0.75;
		float cubsdf = length(max(absVec-vec3(0.75),0.0));	//more accurate. how does speed compare? todo use like this for holes? 
		//float cubsdf = length(max(absVec-vec3(0.75),0.0))-0.15;	//round edge! 
		
		//if (min(absVec.z,min(absVec.x,absVec.y))<0.1){cubsdf += 0.01;}	//abuse of "sdf" -> dark energy effect!!
		
		if (cubsdf>0.005){return cubsdf;}	//early exit if sufficiently outside cube.	what is ideal value?
		
		float maxxy = max(absVec.x,absVec.y);	//square hole
		float maxxz = max(absVec.x,absVec.z);	//square hole
		float maxyz = max(absVec.y,absVec.z);	//square hole
		float minhole = min(min(maxxy,maxxz),maxyz);
		
		cubsdf = max( cubsdf , 0.25-minhole);
		
		//chop smaller holes out TODO incorporate 1st hole cuts into this (above)
		
		//figure out how many iterations.
		int numIters = int(4.0/(1.0+0.03*rayPos.w));	//TODO should use z, and should be from camera
									//numbers guessed really should depend on screen resolution, fov
		
		float divideFactor=1.0;
		for (int ii=0;ii<4;ii++){	//high nums lead to horrible aliasing! TODO depth dependent on distance from cam?
			if (ii==numIters){break;}
			divideFactor*=3.0;
			toObjectVec*=3.0;
			
			//bodge for interesting
			//toObjectVec+=vec3(2.2,5.1,1.1);
			
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/divideFactor);
		}
		
		return cubsdf;
		
		
	}
	
	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			cubsdf = sdfFunc(rayPos);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.z){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>

<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="data/quad.js"></script>

<script type="text/javascript">
/*
basic raymarcher test
initially just an array of cubes, no camera transform
get webgl boilerplate working

then can look at
* multiple scenes (different shaders)
* camera transformation (including ortho. the ray start point can be a varying, and might be varying for persp too if choose a near clip plane)
* speedup by changnig termination condition (basically size of pixel at given distance, but 
* speedup by shooting blocks (cones for perspective camera) and rendering series of increasing resolution depth maps
* fractals!
* consistent alternate version where raymarching shader is applied to surface of an object eg a cube that surrounds the object described by SDF (eg mandelbox), transformed in the vertex shader. (for use in hybrid renderer / to draw fewer pixels)
* hybrid version in scene with pther objects
* shadows
* hybrid shadows?
* etc, etc!
* having SDF and raymarcher in copy accessible to js code too, for collision. 
* using this to implement say, sphere player collider
* normals (derivative of SDF) for rendering and collision response (bounce/ friction?)

*/

var shaderPrograms={};
function initShaders(){
	//shaderProgramFlat = loadShader( "shader-fullscreen-vs", "shader-flatcolor-fs",{
	shaderPrograms.flat = loadShader( "shader-fullscreen-vs", "shader-raymarch8-fs",{
					attributes:["aVertexPosition"],
					uniforms:["fovScale","rayStartIn"]
					});
}

var quadBuffers={};

function initBuffers(){

	loadBufferData(quadBuffers, quadData);

	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
		console.log("buffered. numitems: " + buffer.numItems);
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
		//stuff about normals etc present in 3-sph project got this from, removed here. 
		
		//triangles rather than strip, but no big deal- frag shader does most of the work!
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
}


//copied from 3sphere project. much of this unused since objs here don't have normals, textures
function drawObjectFromBuffers(bufferObj, shaderProg, usesCubeMap){
	prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	/*
	if (bufferObj.vertexNormalBuffer && shaderProg.attributes.aVertexNormal){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	*/
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	/*
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	
	if (usesCubeMap){
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	*/
	//gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	//gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function drawScene(){
	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();

	resizecanvas(1);	//1 for same resolution as displayed. larger number to draw more pixels, observe slowdown on a decent machine
	//resizecanvas(1)
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	//TODO should this be every frame?

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var activeShaderProgram = shaderPrograms.flat;
	gl.useProgram(activeShaderProgram);
	
	gl.uniform3fv(activeShaderProgram.uniforms.fovScale, [gl.viewportWidth/gl.viewportHeight,1,1]);
	//gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,Math.random()]);
	gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,(new Date()).getTime()*0.002 % 8]);
		
	drawObjectFromBuffers(quadBuffers, activeShaderProgram);
}

//first get a gl window with some clearcolor

function init(){

	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );

	canvas = document.getElementById("mycanvas");
	initGL();
	
	//try clearing to green
	gl.clearColor.apply(gl,[0,1,0,1]);
	//gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	initShaders();
	initBuffers();
	gl.disable(gl.DEPTH_TEST);

	requestAnimationFrame(drawScene);
}



</script>
</head>

<body onload="init()">

<canvas id="mycanvas"></canvas>



</body>
</html>