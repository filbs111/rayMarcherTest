<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>raymarcher test</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}
</style>

<!-- vertex shader with tex coords -->
<!-- start simple by just use 1 vec for ray direction. assume camera fixed at zero. likely should include matrix transformation for camera, pass through both ray start and direction as separate varying-->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	varying vec3 mynum;
	uniform mat4 uMVMatrix;
	uniform vec3 fovScale;
	uniform vec3 rayStartIn;
	varying vec3 rayStart;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition,1.0);
		//mynum = 0.5*aVertexPosition.xy + 0.5;
	//	mynum = (aVertexPosition+vec3(0.0,0.0,1.0))*fovScale;	// z=1 for 90deg fov
	
		vec4 transformedCoord = uMVMatrix * vec4((aVertexPosition+vec3(0.0,0.0,1.0))*fovScale,1.0);	//TODO better to just use 3x3 so3 matrix?
		mynum = transformedCoord.xyz;
	
		rayStart = rayStartIn;	//later for near plane or ortho camera, this will vary across camera view.
	}
</script>

<!-- fragment shader -->
<!-- super simple, just flat colour, then shade colour across image to check passing through vertex position stuff ok-->
<script id="shader-flatcolor-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		gl_FragColor = vec4(mynum.xy*0.5+0.5,0.0,1.0);
	}
</script>

<!-- fragment shader -->
<!-- single sphere raymarch-->
<script id="shader-raymarch1-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<10;ii++){
			//get distance estimate from rayPos
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(1.0-0.001*rayPos.w),1.0);
	}
</script>

<!-- fragment shader -->
<!-- square array spheres-->
<script id="shader-raymarch2-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theSphere=vec3(0.0,0.0,10.0);	//position a sphere in view
		for (int ii=0;ii<32;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy+2.0,4.0)-2.0;
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.00002*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres-->
<script id="shader-raymarch3-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere);
			rayPos+=(toSphere-1.0)*rayDir;
		}
		gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch4-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			if (toSphere<0.02){numSteps=float(ii);break;}	//arbitary small number. 
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		gl_FragColor = vec4(vec3(max(0.0,1.0-numSteps/64.0)),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array spheres, break if close-->
<script id="shader-raymarch5-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		//vec3 theSphere=vec3(2.0,2.0,8.0);	//position a sphere in view
		vec3 theSphere=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			float toSphere = length(rayPos.xyz - theSphere) -1.0;
			rayPos+=toSphere*rayDir;
			
			//rayPos = rayDir*rayPos.w;	//should have no effect
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.z){numSteps=float(ii)+(toSphere/(0.005*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
		}
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
	}
</script>

<!-- fragment shader -->
<!-- cube array tori-->
<script id="shader-raymarch6-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		float toSphere;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toSphere = length(vec2(rad,toTorus.z)) -0.25;
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (toSphere<0.005*rayPos.z){numSteps=float(ii)+(toSphere/(0.005*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
			
			rayPos+=toSphere*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		toTorus = rayPos.xyz - theTorus;
		rad = length(toTorus.xy)-1.5;
		float distanceDifference = (length(vec2(rad,toTorus.z)) -0.25) - toSphere;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges-->
<script id="shader-raymarch7-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		vec4 rayDir=vec4(normalize(mynum),1.0);
		vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			//get distance estimate from rayPos
			rayPos.xy =mod(rayPos.xy,4.0);
			//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
			rayPos.z =mod(rayPos.z,8.0);
			
			/*
			toTorus = rayPos.xyz - theTorus;
			rad = length(toTorus.xy)-1.5;
			toObject = length(vec2(rad,toTorus.z)) -0.25;
			*/
			toObjectVec = rayPos.xyz - theTorus;
			vec3 absVec = abs(toObjectVec);
			
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			
			cubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
			
			//chop smaller holes out (will do this iteratively)
			toObjectVec*=3.0;
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/3.0);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.z){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 	
		rayPos.xy =mod(rayPos.xy,4.0);
		rayPos.z =mod(rayPos.z,8.0);
		
		//toTorus = rayPos.xyz - theTorus;
		//rad = length(toTorus.xy)-1.5;
		toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		maxxy = max(absVec.x,absVec.y);
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		
		float newcubsdf;
		newcubsdf = max(max(absVec.z,maxxy)-0.75 , 0.25-minhole);
		
		//chop smaller holes out (will do this iteratively)
		toObjectVec*=3.0;
		toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;	//wrong
		absVec = abs(toObjectVec);
		maxxy = max(absVec.x,absVec.y);	//square hole
		maxxz = max(absVec.x,absVec.z);	//square hole
		maxyz = max(absVec.y,absVec.z);	//square hole
		minhole = min(min(maxxy,maxxz),maxyz);
		newcubsdf = max(newcubsdf , (0.25-minhole)/3.0);
		
		float distanceDifference = newcubsdf - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>


<!-- fragment shader -->
<!-- cube array menger sponges , use function instead of copy/paste-->
<script id="shader-raymarch8-fs" type="x-shader/x-fragment">
	precision mediump float;
	//precision highp float;
	varying vec3 mynum;
	varying vec3 rayStart;

	vec3 theTorus=vec3(2.0,2.0,4.0);	//position a sphere in view
	
	float sdfFunc(inout vec4 rayPos){
		rayPos.xy =mod(rayPos.xy,4.0);
		//rayPos.z =mod(rayPos.z+8.0,16.0)-8.0;
		rayPos.z =mod(rayPos.z,8.0);
		
		vec3 toObjectVec = rayPos.xyz - theTorus;
		vec3 absVec = abs(toObjectVec);
		
		//float cubsdf = max(absVec.z,maxxy)-0.75;
		float cubsdf = length(max(absVec-vec3(0.75),0.0));	//more accurate. how does speed compare? todo use like this for holes? 
		//float cubsdf = length(max(absVec-vec3(0.75),0.0))-0.15;	//round edge! 
		
		//if (min(absVec.z,min(absVec.x,absVec.y))<0.1){cubsdf += 0.01;}	//abuse of "sdf" -> dark energy effect!!
		
		if (cubsdf>0.005){return cubsdf;}	//early exit if sufficiently outside cube.	what is ideal value?
		
		float maxxy = max(absVec.x,absVec.y);	//square hole
		float maxxz = max(absVec.x,absVec.z);	//square hole
		float maxyz = max(absVec.y,absVec.z);	//square hole
		float minhole = min(min(maxxy,maxxz),maxyz);
		
		cubsdf = max( cubsdf , 0.25-minhole);
		
		//chop smaller holes out TODO incorporate 1st hole cuts into this (above)
		
		//figure out how many iterations.
		int numIters = int(4.0/(1.0+0.03*rayPos.w));	//TODO should use z, and should be from camera
									//numbers guessed really should depend on screen resolution, fov
		
		float divideFactor=1.0;
		for (int ii=0;ii<4;ii++){	//high nums lead to horrible aliasing! TODO depth dependent on distance from cam?
			if (ii==numIters){break;}
			divideFactor*=3.0;
			toObjectVec*=3.0;
			
			//bodge for interesting
			//toObjectVec+=vec3(2.2,5.1,1.1);
			
			toObjectVec = mod(toObjectVec+0.75,1.5)-0.75;
			absVec = abs(toObjectVec);
			maxxy = max(absVec.x,absVec.y);	//square hole
			maxxz = max(absVec.x,absVec.z);	//square hole
			maxyz = max(absVec.y,absVec.z);	//square hole
			minhole = min(min(maxxy,maxxz),maxyz);
			cubsdf = max(cubsdf , (0.25-minhole)/divideFactor);
		}
		
		return cubsdf;
		
		
	}
	
	void main(void) {
		//fixed number of iterations raymarch. colour at end relates to distance marched (and tends to some value as -> inf)
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		//vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		//stereographic projection. see https://en.wikipedia.org/wiki/Stereographic_projection
		vec3 mynumAdj = mynum/mynum.z;	//adjust to make z 1. can still adjust uniform to change scaling
		float rsq = dot(mynumAdj.xy,mynumAdj.xy); 
			//length of below is rsq+1. is manual normalising better than calling normalize()?
		float denom = 1.0/(rsq+1.0);
		vec4 rayDir = vec4( mynumAdj*vec3(2.0,2.0,1.0-rsq)*denom , 1.0);	//-ve z vs inverse stereographic formula. guess because std stereographic is projection onto z=-1
		
		float numSteps=64.0;
		vec3 toTorus;
		float rad;
		vec3 toObjectVec;
		float cubsdf;
		float maxxy;
		float maxxz;
		float maxyz;
		float minhole;
		for (int ii=0;ii<64;ii++){
			cubsdf = sdfFunc(rayPos);
			
			//if (toSphere<0.005*rayPos.z){numSteps=float(ii);break;}	//arbitary small number. 
			if (cubsdf<0.00025*rayPos.z){numSteps=float(ii)+(cubsdf/(0.00025*rayPos.z));break;}	//guess. smoother. TODO should be camera z ( since have nonzero raystart)
					//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
					//TODO should use something else for stereographic projection camera (relates to size of pixel) 
			rayPos+=cubsdf*rayDir;
		}
		
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		
		//gl_FragColor = vec4(vec3(max(0.0,1.0-0.004*rayPos.w)),1.0);
		float mycol=max(0.0,1.0-numSteps/64.0);
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		//gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol),1.0);
		//gl_FragColor = vec4(vec3(lightval),1.0);
	}
</script>

<!-- fragment shader -->
<!-- mandelbox copy paste from forum-->
<script id="shader-raymarch9-fs" type="x-shader/x-fragment">
	//basically copied from Rrola's code here http://www.fractalforums.com/3d-fractal-generation/a-mandelbox-distance-estimate-formula/15/
	//picked that because alter in thread, guess better optimised than earlier.

	#define RAYSTEPSI 64
	#define RAYSTEPSF 64.0
	#define RAYTERMINCOND 0.001
	
	#define ITERS 16
	#define SCALE -1.75
	#define MR2 0.001
	
	#define C1 2.75
	//C1 = abs(SCALE-1.0);
	
	#define CUBELIMIT 2.0 
	
	//For scale < -1 the mandelbox sides have length 4 and for 1 < scale <= 4?n+1 they have length 4(scale+1)/(scale-1)
	// what is n ? assuming condition correct (at least, n>=1) 
	
	// scale 1 , length 4(2/0)	-> inf!
	// scale 1.5, length 4(2.5/0.5) -> 20			half length =10
	// scale 1.75, length 4(2.75/0.75) -> 14.666	half length 7.333
	// scale 2 , length 4(3/1)  -> 12				half length =6
	// scale 2.5, length 4(3.5/1.5) -> 9.333		half length = 4.666
	// scale 3 , length 4(4/2) -> 8					half length =4
	// scale 4, length 4(5/3) -> 6.6666				half length = 3.333
	
	precision mediump float;
	varying vec3 mynum;
	varying vec3 rayStart;
	
	vec4 scalevec;
	float C2;	//guess faster to hard code than calculate in main;

	float sdfFunc(in vec4 position){
		//should calculate halflength outside (eg by define or uniform)
		vec3 distFromSides = max(abs(position.xyz) - CUBELIMIT , 0.0);

		float distFromCube = length(distFromSides);
		if (distFromCube>0.5){return distFromCube;}	//added some buffer outside - iterations outside this fast, buffer allows marching through cube limit to inside
													//TODO find best number
	
	  // distance estimate
	  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
	  for (int i=0; i<ITERS; i++) {	//hard coded iters? can set by define?
		p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3
		float r2 = dot(p.xyz, p.xyz);  // dp3
		p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
		p.xyzw = p*scalevec + p0;  // mad4
	  }
		
	  return (length(p.xyz) - C1) / p.w - C2;
	  //return -(length(p.xyz) - C1) / p.w - C2;
	  //return max( veclength , (length(p.xyz) - C1) / p.w - C2 );	//this SHOULD work...
	}
	
	void main(void){
		scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
		
		C2 = pow(abs(SCALE), float(1-ITERS));
	
		float cubsdf;
		float numSteps=RAYSTEPSF;
		vec4 rayPos=vec4(vec3(rayStart),0.0);	//last number is total ray length.
		
		rayPos+=vec4(0.0,0.0,-6.0,0.0);	//bodge to move object??
		float startz = rayPos.z;
		
		vec4 rayDir=vec4(normalize(mynum),1.0);	//rectilinear camera
		
		for (int ii=0;ii<RAYSTEPSI;ii++){
			cubsdf = sdfFunc(rayPos);
			//other's sdf might not return 4th as length
			
			float inCameraFrameZ = rayPos.z-startz;
			if (cubsdf<RAYTERMINCOND*inCameraFrameZ){numSteps=float(ii)+(cubsdf/(RAYTERMINCOND*inCameraFrameZ));break;}	
			
			//needed to make number smaller with cube to reduce artifacts (effectively wrong normals). rounding edges maybe better fix
			rayPos+=cubsdf*rayDir;
		}
	
	
		//dot surface normal with light direction for gradient skylight. getting surface normal requires 3 more SDF samples, eg displaced by small x,y,z
		//if want to dot normal with direction, just do one sample
		//todo make this neat by using a function for sdf, check no speed lost
		float smallDisp = 0.00001;	//some arbitrary small number displacement. should be small but not run into float precision problems
									//runs into problems when ray pointed at empty space
															
		rayPos+=vec4(0.0,smallDisp,0.0,0.0); 
		
		float distanceDifference = sdfFunc(rayPos) - cubsdf;
		float lightval = (distanceDifference/smallDisp)*0.5+0.5;	//map -1 to 1 to 0 to 1
		float mycol=max(0.0,1.0-numSteps/RAYSTEPSF);
		
		gl_FragColor = vec4(vec3(mycol*mycol,mycol,mycol)*lightval,1.0);
		
		return;
		//override with debug rendering
		gl_FragColor.x = mycol;	//shows that all ray steps used, so doesn't get sufficiently close to break. ?!!
		gl_FragColor.y = lightval;	//doesn't seem to be working right. is surface finding reliable?
		gl_FragColor.z = max(0.0,1.0-0.25*rayPos.w);
	}

</script>


<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="data/quad.js"></script>

<script type="text/javascript">
/*
basic raymarcher test
initially just an array of cubes, no camera transform
get webgl boilerplate working

then can look at
* multiple scenes (different shaders)
* camera transformation (including ortho. the ray start point can be a varying, and might be varying for persp too if choose a near clip plane)
* speedup by changnig termination condition (basically size of pixel at given distance, but 
* speedup by shooting blocks (cones for perspective camera) and rendering series of increasing resolution depth maps
* fractals!
* consistent alternate version where raymarching shader is applied to surface of an object eg a cube that surrounds the object described by SDF (eg mandelbox), transformed in the vertex shader. (for use in hybrid renderer / to draw fewer pixels)
* hybrid version in scene with pther objects
* shadows
* hybrid shadows?
* etc, etc!
* having SDF and raymarcher in copy accessible to js code too, for collision. 
* using this to implement say, sphere player collider
* normals (derivative of SDF) for rendering and collision response (bounce/ friction?)

*/

var shaderPrograms={};
function initShaders(){
	//shaderProgramFlat = loadShader( "shader-fullscreen-vs", "shader-flatcolor-fs",{
	shaderPrograms.flat = loadShader( "shader-fullscreen-vs", "shader-raymarch9-fs",{
					attributes:["aVertexPosition"],
					uniforms:["uMVMatrix","fovScale","rayStartIn"]
					});
}

var quadBuffers={};

function initBuffers(){

	loadBufferData(quadBuffers, quadData);

	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
		console.log("buffered. numitems: " + buffer.numItems);
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
		//stuff about normals etc present in 3-sph project got this from, removed here. 
		
		//triangles rather than strip, but no big deal- frag shader does most of the work!
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
}


//copied from 3sphere project. much of this unused since objs here don't have normals, textures
function drawObjectFromBuffers(bufferObj, shaderProg, usesCubeMap){
	prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg, usesCubeMap){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	/*
	if (bufferObj.vertexNormalBuffer && shaderProg.attributes.aVertexNormal){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	*/
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	/*
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	
	if (usesCubeMap){
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	*/
	//gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function drawScene(){
	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();

	resizecanvas(1);	//1 for same resolution as displayed. larger number to draw more pixels, observe slowdown on a decent machine
	//resizecanvas(1)
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	//TODO should this be every frame?

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var activeShaderProgram = shaderPrograms.flat;
	gl.useProgram(activeShaderProgram);
	
	gl.uniform3fv(activeShaderProgram.uniforms.fovScale, [gl.viewportWidth/gl.viewportHeight,1,1]);
	//gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,Math.random()]);
	//gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, [0,0,(new Date()).getTime()*0.0005 % 4]);
	gl.uniform3fv(activeShaderProgram.uniforms.rayStartIn, camPos);
	
	drawObjectFromBuffers(quadBuffers, activeShaderProgram);
}

//first get a gl window with some clearcolor

var camPos = [0,0,0];
var mvMatrix = mat4.create();
mat4.identity(mvMatrix);

var mouseInfo = {
	x:0,
	y:0,
	dragging: false,
	lastPointingDir:{},
	currentPointingDir:{x:0,y:0,z:1,w:1}
};

function init(){

	window.addEventListener("keydown",function(e){
		console.log(e.keyCode);
		//WASD = 87,65,83,68
		var camStep = 0.01;
		var camMove = [0,0,0];
		if (e.keyCode == 87){camMove[2]+=camStep;}
		if (e.keyCode == 83){camMove[2]-=camStep;}
		if (e.keyCode == 65){camMove[0]-=camStep;}
		if (e.keyCode == 68){camMove[0]+=camStep;}
		//move camPos in camera direction. TODO just use mvMatrix.
		//probably neater way to do this, but
		camPos[0] += camMove[0]*mvMatrix[0] + camMove[1]*mvMatrix[4] + + camMove[2]*mvMatrix[8];
		camPos[1] += camMove[0]*mvMatrix[1] + camMove[1]*mvMatrix[5] + + camMove[2]*mvMatrix[9];
		camPos[2] += camMove[0]*mvMatrix[2] + camMove[1]*mvMatrix[6] + + camMove[2]*mvMatrix[10];
		
	});

	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );

	canvas = document.getElementById("mycanvas");
	
	
	//mouse code copied from 3sphere-explorer
	canvas.addEventListener("mousedown", function(evt){
		mouseInfo.x = evt.offsetX;
		mouseInfo.y = evt.offsetY;
		mouseInfo.dragging = true;
		mouseInfo.lastPointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
	});
	canvas.addEventListener("mouseup", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mouseout", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mousemove", function(evt){
		mouseInfo.currentPointingDir = getPointingDirectionFromScreenCoordinate({x:evt.offsetX, y: evt.offsetY});
		if (mouseInfo.dragging){
			var pointingDir = mouseInfo.currentPointingDir;
			//console.log("pointingDir = " + pointingDir);
			
			//get the direction of current and previous mouse position.
			//do a cross product to work out the angle rotated
			//and rotate the player by this amount
			
			var crossProd = crossProductHomgenous(pointingDir, mouseInfo.lastPointingDir);
			mouseInfo.lastPointingDir = pointingDir;
			
			//rotate player 
			//guess have signs here because of unplanned handedness of screen, 3d co-ord systems
			//note switched some signs vs 3sphere-explorer version!
			var rotateAmt = [-crossProd.x / crossProd.w, crossProd.y / crossProd.w, -crossProd.z / crossProd.w];
			rotatePlayer(rotateAmt);
			
		}
	});
	function rotatePlayer(rotateAmt){
		//modify mvMatrix
		//glmatrix annoyingly takes an axis and angle, rather than axis*angle.
		//so have to do some bollocks
		var vecLength = rotateAmt.reduce(function(accumulator, currentValue){return accumulator + currentValue*currentValue;},0);
		vecLength=Math.sqrt(vecLength);
		var axis = rotateAmt.map(function(currentValue){return currentValue/vecLength;});

		mat4.rotate(mvMatrix,vecLength,axis);	
	}
	
	initGL();
	
	//try clearing to green
	gl.clearColor.apply(gl,[0,1,0,1]);
	//gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	initShaders();
	initBuffers();
	gl.disable(gl.DEPTH_TEST);

	requestAnimationFrame(drawScene);
	
	
	//to facilitate mouse drag to rotate (copied from 3sphere-explorer)
	//TODO have this work with a stereographic projection camera (or something inbetween)
	//should look at webgl-wideanglecamera project.
	var mainCamFov=90.0;	//TODO configurable FOV 
	
	function getPointingDirectionFromScreenCoordinate(coords){
		var maxyvert = 1.0;	
		var maxxvert = screenAspect;
		
		var xpos = maxxvert*(coords.x*2.0/gl.viewportWidth   -1.0 );
		var ypos = maxyvert*(coords.y*2.0/gl.viewportHeight   -1.0 );
		var radsq = xpos*xpos + ypos*ypos;
		var zpos = 1.0/Math.tan(mainCamFov*Math.PI/360); //TODO precalc

		//normalise - use sending back homogenous co-ords because maybe a tiny amount more efficient since cross producting anyway
		var mag= Math.sqrt(radsq + zpos*zpos);
		
		return {
			x: xpos,
			y: ypos,
			z: zpos,
			w: mag
		}
	}
	function crossProductHomgenous(dir1, dir2){
		var output ={};
		output.x = dir1.y * dir2.z - dir1.z * dir2.y; 
		output.y = dir1.z * dir2.x - dir1.x * dir2.z; 
		output.z = dir1.x * dir2.y - dir1.y * dir2.x;
		output.w = dir1.w * dir2.w;
		return output;
	}
}



</script>
</head>

<body onload="init()">

<canvas id="mycanvas"></canvas>



</body>
</html>